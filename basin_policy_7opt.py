

## 7-policy, Soil-specific Targeted Policy Optimization

######################################################################
################## IMPORTING DATA AND SETTING UP #####################
######################################################################
def import_data():
   
    out = pd.read_csv("C:\\Users\\BBarnhart.DOMAIN1\\OneDrive - National Council for Air and Stream Improvement Inc\\Projects\\Other\\Legacy\\brisbane\\7_choices_updated\\Fulldata.csv")
    
    #print(list(out))
    
    scen1 = out[['Cellno', 'N210_Nloss', 'N210_GM', 'Transport_coefficient','Subcatchments']]
    scen1['scenario'] = 210
    scen1.columns = ['cellno','loss','gm','transport_coefficient','sub','scenario']
    
    scen2 = out[['Cellno', 'N180_Nloss', 'N180_GM', 'Transport_coefficient','Subcatchments']]
    scen2['scenario'] = 180
    scen2.columns = ['cellno','loss','gm','transport_coefficient','sub','scenario']
    
    scen3 = out[['Cellno', 'N150_Nloss', 'N150_GM', 'Transport_coefficient','Subcatchments']]
    scen3['scenario'] = 150
    scen3.columns = ['cellno','loss','gm','transport_coefficient','sub','scenario']
    
    scen4 = out[['Cellno', 'N120_Nloss', 'N120_GM', 'Transport_coefficient','Subcatchments']]
    scen4['scenario'] = 120
    scen4.columns = ['cellno','loss','gm','transport_coefficient','sub','scenario']
    
    scen5 = out[['Cellno', 'N090_Nloss', 'N090_GM', 'Transport_coefficient','Subcatchments']]
    scen5['scenario'] = 90
    scen5.columns = ['cellno','loss','gm','transport_coefficient','sub','scenario']
    
    scen6 = out[['Cellno', 'N060_Nloss', 'N060_GM', 'Transport_coefficient','Subcatchments']]
    scen6['scenario'] = 60
    scen6.columns = ['cellno','loss','gm','transport_coefficient','sub','scenario']
    
    scen7 = out[['Cellno', 'N040_Nloss', 'N040_GM', 'Transport_coefficient','Subcatchments']]
    scen7['scenario'] = 40
    scen7.columns = ['cellno','loss','gm','transport_coefficient','sub','scenario']
    
    combined = pd.concat([scen1,scen2,scen3,scen4,scen5,scen6,scen7],axis=0)
    
    return scen1, scen2, scen3, scen4, scen5, scen6, scen7, combined


#print(combined)
######################################################################
######################################################################
######################################################################

######################################################################
############# OBJECTIVE FUNCTION #####################################
######################################################################
def get_objs(cmatrix,scen1,scen2,scen3,scen4,scen5,scen6,scen7,combined,numSubs,N):
    #cmatrix is generated by generator
    #BUT, it needs zeros in spots for N210 policy. 
    cmatrix = [0.] + cmatrix
    
    #initialize Variables
    curpol = [np.nan for i in range(N)]
    cmatrix_chosen = [np.nan for i in range(N)]


    #Allocate incentives for each of the 19 subbasins. 
    incen1 = cmatrix[0]
    incen2 = cmatrix[1]
    incen3 = cmatrix[2]
    incen4 = cmatrix[3]
    incen5 = cmatrix[4]
    incen6 = cmatrix[5]
    incen7 = cmatrix[6]
    
    listofSubs = scen1['sub'].astype('category').unique()
    
    #Loop through cells
    for i in range(N):
        #Loop through subcatchments. 
        for j in range(numSubs):
            if (scen1['sub'].values[i] == listofSubs[j]):
                temp = max(scen1['gm'].values[i] + incen1,
                    scen2['gm'].values[i] + incen2,
                    scen3['gm'].values[i] + incen3,
                    scen4['gm'].values[i] + incen4,
                    scen5['gm'].values[i] + incen5,
                    scen6['gm'].values[i] + incen6,
                    scen7['gm'].values[i] + incen7)
                if (temp == scen1['gm'].values[i] + incen1):
                    curpol[i] = 210; cmatrix_chosen[i] = incen1
                elif (temp == scen2['gm'].values[i] + incen2):
                    curpol[i] = 180; cmatrix_chosen[i] = incen2
                elif (temp == scen3['gm'].values[i] + incen3):
                    curpol[i] = 150; cmatrix_chosen[i] = incen3
                elif (temp == scen4['gm'].values[i] + incen4):
                    curpol[i] = 120; cmatrix_chosen[i] = incen4
                elif (temp == scen5['gm'].values[i] + incen5):
                    curpol[i] = 90; cmatrix_chosen[i] = incen5
                elif (temp == scen6['gm'].values[i] + incen6):
                    curpol[i] = 60; cmatrix_chosen[i] = incen6
                elif (temp == scen7['gm'].values[i] + incen7):
                    curpol[i] = 40; cmatrix_chosen[i] = incen7

    #19 is number of subcatchments
    lookup = np.zeros((N,2))
    seq = [i for i in range(N)]
    cellno = combined['cellno'].values[0:4020].tolist() 
    lookup[:,0] = seq
    lookup[:,1] = cellno

    #First subout.
    subout = combined[(combined.cellno == lookup[0,1]) & (combined.scenario == curpol[0])]

    #Rest of the subouts. 
    for i in range(1,N):
        subout = subout.append(combined[(combined.cellno == lookup[i,1]) & (combined.scenario == curpol[i])])

    #Rounding 
    subout['gm'] = round(subout['gm'],2)

    #Add Paymentub
    subout['gm_plus_incentive'] = round(subout['gm'] + cmatrix_chosen,2)

    #Incorporate Transport_Coefficients 
    subout['transported_Nloss'] = subout['transport_coefficient']*subout['loss']

    #nitrogen loss objective function
    #Nloss_obj = np.round(np.sum(subout.loss),2)
    Nloss_obj = np.round(np.sum(subout.transported_Nloss),2) 
    Pcost_obj = np.round(np.sum(cmatrix_chosen),2)

    return [Nloss_obj, Pcost_obj]


######################################################################
######################################################################
######################################################################

######################################################################
############# Optimization Algorithm #################################
######################################################################
def generate_cmatrix(random,args):
    cmatrix_temp = [np.round(random.uniform(0,5000),2) for i in range(6)]
    return cmatrix_temp

def evaluate_cmatrix(candidates,args):
    print('Evaluating Population...')
    #Would like to move these outside of the evaluation but not sure how
    #to pass these arguments to get_objs. 
    N = 4020
    numSubs = 19
    
    scen1, scen2, scen3, scen4, scen5, scen6, scen7, combined = import_data()
    
    fitness = []
    for cs in candidates:
        [f1, f2] = get_objs(cs,scen1,scen2,scen3,scen4,scen5,scen6,scen7,combined,numSubs,N)
        fitness.append(inspyred.ec.emo.Pareto([f1,f2]))
        #print(fitness)
    return fitness


#Import and prep data from .csv file using pandas. 
import pandas as pd
import numpy as np
import random
import inspyred
from random import Random
from time import time

start_time = time()
pd.options.mode.chained_assignment = None



def main():

    #Import data. 
    #scen1, scen2, scen3, scen4, combined = import_data()
    #Number of cells
    #N = 4020
    #Number of managements 
    #m = 4

    prng = random.Random()
    prng.seed(time())

    ea = inspyred.ec.emo.NSGA2(prng)
    ea.variator = [inspyred.ec.variators.simulated_binary_crossover,
                   inspyred.ec.variators.gaussian_mutation]
    ea.terminator = inspyred.ec.terminators.generation_termination
    ea.observer = inspyred.ec.observers.file_observer
    final_pop = ea.evolve(generator=generate_cmatrix,
                          evaluator=inspyred.ec.evaluators.parallel_evaluation_mp,
                          mp_evaluator=evaluate_cmatrix,
                          mp_num_ncpus=12,
                          bounder=inspyred.ec.Bounder(0,5000),
                          pop_size=96,
                          max_generations=100,
                          maximize=False,
                          crossover_rate=0.75,
                          sbx_distribution=10,
                          seeds=[[0. for i in range(6)]]
                          )

    print('final population is here.')
    print(final_pop)
    print("--- %s seconds ---" % (time() - start_time))

if __name__ == '__main__':
    main()
    