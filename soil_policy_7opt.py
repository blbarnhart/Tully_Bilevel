

## 7-policy, Soil-specific Targeted Policy Optimization

######################################################################
################## IMPORTING DATA AND SETTING UP #####################
######################################################################

def import_data():
   
    out = pd.read_csv("C:\\Users\\BBarnhart.DOMAIN1\\OneDrive - National Council for Air and Stream Improvement Inc\\Projects\\Other\\Legacy\\brisbane\\7_choices_updated\\Tully_Bilevel\\Fulldata.csv")
    
    #print(list(out))
    
    scen1 = out[['Cellno', 'N210_Nloss', 'N210_GM', 'Transport_coefficient','SolCls1m2', 'SolCls2m2', 'SolCls3m2', 'SolCls4m2']]
    scen1['scenario'] = 210
    scen1.columns = ['cellno','loss','gm','transport_coefficient','sol1','sol2','sol3','sol4','scenario']
    
    scen2 = out[['Cellno', 'N180_Nloss', 'N180_GM', 'Transport_coefficient','SolCls1m2','SolCls2m2','SolCls3m2','SolCls4m2']]
    scen2['scenario'] = 180
    scen2.columns = ['cellno','loss','gm','transport_coefficient','sol1','sol2','sol3','sol4','scenario']
    
    scen3 = out[['Cellno', 'N150_Nloss', 'N150_GM', 'Transport_coefficient','SolCls1m2','SolCls2m2','SolCls3m2','SolCls4m2']]
    scen3['scenario'] = 150
    scen3.columns = ['cellno','loss','gm','transport_coefficient','sol1','sol2','sol3','sol4','scenario']
    
    scen4 = out[['Cellno', 'N120_Nloss', 'N120_GM', 'Transport_coefficient','SolCls1m2','SolCls2m2','SolCls3m2','SolCls4m2']]
    scen4['scenario'] = 120
    scen4.columns = ['cellno','loss','gm','transport_coefficient','sol1','sol2','sol3','sol4','scenario']
    
    scen5 = out[['Cellno', 'N090_Nloss', 'N090_GM', 'Transport_coefficient','SolCls1m2','SolCls2m2','SolCls3m2','SolCls4m2']]
    scen5['scenario'] = 90
    scen5.columns = ['cellno','loss','gm','transport_coefficient','sol1','sol2','sol3','sol4','scenario']
    
    scen6 = out[['Cellno', 'N060_Nloss', 'N060_GM', 'Transport_coefficient','SolCls1m2','SolCls2m2','SolCls3m2','SolCls4m2']]
    scen6['scenario'] = 60
    scen6.columns = ['cellno','loss','gm','transport_coefficient','sol1','sol2','sol3','sol4','scenario']
    
    scen7 = out[['Cellno', 'N040_Nloss', 'N040_GM', 'Transport_coefficient','SolCls1m2','SolCls2m2','SolCls3m2','SolCls4m2']]
    scen7['scenario'] = 40
    scen7.columns = ['cellno','loss','gm','transport_coefficient','sol1','sol2','sol3','sol4','scenario']
    
    combined = pd.concat([scen1,scen2,scen3,scen4,scen5,scen6,scen7],axis=0)
    
    return scen1, scen2, scen3, scen4, scen5, scen6, scen7, combined


#print(combined)
######################################################################
######################################################################
######################################################################

######################################################################
############# OBJECTIVE FUNCTION #####################################
######################################################################
def get_objs(cmatrix,scen1,scen2,scen3,scen4,scen5,scen6,scen7,combined,N):
    
    #cmatrix is generated by generator
    #BUT, it needs zeros in spots for N210 policy. 
    cmatrix = [0.,0.,0.,0.] + cmatrix
    
    #initialize Variables
    curpol = [np.nan for i in range(N)]
    cmatrix_chosen = [np.nan for i in range(N)]


    #This section allocates the curpol and cmatrix_chosen 
    #using simple profit maximization.
    for i in range(N):
        incen1 = (cmatrix[0]*scen1['sol1'].values[i]) + (cmatrix[1]*scen1['sol2'].values[i]) + (cmatrix[2]*scen1['sol3'].values[i]) + (cmatrix[3]*scen1['sol4'].values[i])
        incen2 = (cmatrix[4]*scen2['sol1'].values[i]) + (cmatrix[5]*scen2['sol2'].values[i]) + (cmatrix[6]*scen2['sol3'].values[i]) + (cmatrix[7]*scen2['sol4'].values[i])
        incen3 = (cmatrix[8]*scen3['sol1'].values[i]) + (cmatrix[9]*scen3['sol2'].values[i]) + (cmatrix[10]*scen3['sol3'].values[i]) + (cmatrix[11]*scen3['sol4'].values[i])
        incen4 = (cmatrix[12]*scen4['sol1'].values[i]) + (cmatrix[13]*scen4['sol2'].values[i]) + (cmatrix[14]*scen4['sol3'].values[i]) + (cmatrix[15]*scen4['sol4'].values[i])
        incen5 = (cmatrix[16]*scen4['sol1'].values[i]) + (cmatrix[17]*scen4['sol2'].values[i]) + (cmatrix[18]*scen4['sol3'].values[i]) + (cmatrix[19]*scen4['sol4'].values[i])
        incen6 = (cmatrix[20]*scen4['sol1'].values[i]) + (cmatrix[21]*scen4['sol2'].values[i]) + (cmatrix[22]*scen4['sol3'].values[i]) + (cmatrix[23]*scen4['sol4'].values[i])
        incen7 = (cmatrix[24]*scen4['sol1'].values[i]) + (cmatrix[25]*scen4['sol2'].values[i]) + (cmatrix[26]*scen4['sol3'].values[i]) + (cmatrix[27]*scen4['sol4'].values[i])

        temp = max(scen1['gm'].values[i] + incen1,
                   scen2['gm'].values[i] + incen2,
                   scen3['gm'].values[i] + incen3,
                   scen4['gm'].values[i] + incen4,
                   scen5['gm'].values[i] + incen5,
                   scen6['gm'].values[i] + incen6,
                   scen7['gm'].values[i] + incen7                  
                   )

        if (temp == scen1['gm'].values[i] + incen1):
            curpol[i] = 210; cmatrix_chosen[i] = incen1
        elif (temp == scen2['gm'].values[i] + incen2):
            curpol[i] = 180; cmatrix_chosen[i] = incen2
        elif (temp == scen3['gm'].values[i] + incen3):
            curpol[i] = 150; cmatrix_chosen[i] = incen3
        elif (temp == scen4['gm'].values[i] + incen4):
            curpol[i] = 120; cmatrix_chosen[i] = incen4
        elif (temp == scen5['gm'].values[i] + incen5):
            curpol[i] = 90; cmatrix_chosen[i] = incen5
        elif (temp == scen6['gm'].values[i] + incen6):
            curpol[i] = 60; cmatrix_chosen[i] = incen6
        elif (temp == scen7['gm'].values[i] + incen7):
            curpol[i] = 40; cmatrix_chosen[i] = incen7

        del temp, incen1, incen2, incen3, incen4, incen5, incen6, incen7 
    
    
    lookup = np.zeros((N,2))
    seq = [i for i in range(N)]
    cellno = combined['cellno'].values[0:N].tolist() 
    lookup[:,0] = seq
    lookup[:,1] = cellno
    
    #First subout.
    subout = combined[(combined.cellno == lookup[0,1]) & (combined.scenario == curpol[0])]
    
    #Rest of the subouts. 
    for i in range(1,N):
        subout = subout.append(combined[(combined.cellno == lookup[i,1]) & (combined.scenario == curpol[i])])
    
    #Add Paymentub
    subout['gm_plus_incentive'] = subout['gm'] + cmatrix_chosen
    
    #Incorporate Transport_Coefficients 
    subout['transported_Nloss'] = subout['transport_coefficient']*subout['loss']
    
    #nitrogen loss objective function
    #Nloss_obj = np.round(np.sum(subout.loss),2)
    Nloss_obj = np.round(np.sum(subout.transported_Nloss),2) 
    Pcost_obj = np.round(np.sum(cmatrix_chosen),2)

    return [Nloss_obj, Pcost_obj]
######################################################################
######################################################################
######################################################################

######################################################################
############# Optimization Algorithm #################################
######################################################################
def generate_cmatrix(random,args):
    cmatrix_temp = [np.round(random.uniform(0,0.06),3) for i in range(24)]
    return cmatrix_temp

def evaluate_cmatrix(candidates,args):
    print('Evaluating Population...')
    #Would like to move these outside of the evaluation but not sure how
    #to pass these arguments to get_objs. 
    N = 4020
    scen1, scen2, scen3, scen4, scen5, scen6, scen7, combined = import_data()
    
    fitness = []
    for cs in candidates:
        [f1, f2] = get_objs(cs,scen1,scen2,scen3,scen4,scen5,scen6,scen7,combined,N)
        fitness.append(inspyred.ec.emo.Pareto([f1,f2]))
        #print(fitness)
    return fitness


#Import and prep data from .csv file using pandas. 
import pandas as pd
import numpy as np
import random
import inspyred
from random import Random
from time import time

start_time = time()
pd.options.mode.chained_assignment = None



def main():

    #Import data. 
    #scen1, scen2, scen3, scen4, combined = import_data()
    #Number of cells
    #N = 4020
    #Number of managements 
    #m = 4

    prng = random.Random()
    prng.seed(time())

    ea = inspyred.ec.emo.NSGA2(prng)
    ea.variator = [inspyred.ec.variators.simulated_binary_crossover,
                   inspyred.ec.variators.gaussian_mutation]
    ea.terminator = inspyred.ec.terminators.generation_termination
    ea.observer = inspyred.ec.observers.file_observer
    final_pop = ea.evolve(generator=generate_cmatrix,
                          evaluator=inspyred.ec.evaluators.parallel_evaluation_mp,
                          mp_evaluator=evaluate_cmatrix,
                          mp_num_ncpus=12,
                          bounder=inspyred.ec.Bounder(0,0.06),
                          pop_size=192,
                          max_generations=500,
                          maximize=False,
                          crossover_rate=0.75,
                          sbx_distribution=10,
                          seeds=[[0. for i in range(24)]]
                          )

    print('final population is here.')
    print(final_pop)
    print("--- %s seconds ---" % (time() - start_time))

if __name__ == '__main__':
    main()
    